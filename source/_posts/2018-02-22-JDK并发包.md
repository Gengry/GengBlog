---
title: JDK并发包
date: 2018-02-22 10:44:02
tags:
categories:
---

## 同步工具
<!-- more -->
### ReentranLock

高版本的jdk中已经对synchronized做了足够多的优化，普通的场景下它的性能已经非常接近ReentrantLock。所以一些简单的场景不必过分纠结这两者之间的性能问题。
下面这个例子反而使用synchronized的耗时小于使用ReentrantLock。

#### 可重入

``` java
public class ReenterLock implements Runnable {
    //可重入锁的使用
    public static ReentrantLock lock = new ReentrantLock();
    public static int i = 0;
    @Override
    public void run() {
        for(int j=0; j<1000000;j++){
            //加锁
            lock.lock();
            try{
                i++;
            }finally {
                //释放锁
                lock.unlock();
            }
        }
    }

/*  @Override
    public void run() {
        for(int j=0; j<1000000;j++) {
            synchronized (this){
                i++;
            }
        }
    }*/

    public static void main(String[] args) throws InterruptedException {
        long time1 = System.currentTimeMillis();
        ReenterLock tl = new ReenterLock();
        Thread t1 = new Thread(tl);
        Thread t2 = new Thread(tl);
        t1.start();t2.start();
        t1.join();t2.join();
        long time2 = System.currentTimeMillis();
        System.out.println(i);
        System.out.println(time2-time1);
    }
}
```

如果在一个线程中多次使用了加锁操作，就需要有对应数量的释放锁操作。

```java
@Override
    public void run() {
        for(int j=0; j<1000000;j++){
            //加锁
            lock.lock();
			lock.lock();
            try{
                i++;
            }finally {
                //释放锁
                lock.unlock();
				lock.unlock();
            }
        }
    }
```

下面我们加两次锁，只释放一次锁执行一下。
```java
@Override
    public void run() {
        for(int j=0; j<1000000;j++){
            //加锁
            lock.lock();
			lock.lock();
            try{
                i++;
            }finally {
                //释放锁
                lock.unlock();
            }
        }
    }
```
就会发现程序卡住了，一直没有执行结束
![](https://raw.githubusercontent.com/Gengry/blogImage/master/20180222/1.jpg)  
我们通过使用jdk的两个命令来看看发生了什么
![](https://raw.githubusercontent.com/Gengry/blogImage/master/20180222/2.jpg)  
通过jps获取到这个进程的id
通过jstack看看这个进程的栈信息
可以看到Thread-1处于waiting状态一直在等在某种条件，就是等待另一个线程释放锁。
所在了第13行，也就是lock.lock();

#### 可中断

在加锁的同时可以去响应中断，如果发生了死锁，或者意料之外的情况，在一个锁上卡了很久，还是有办法把这个线程唤醒，不至于永久性的卡死下去。

``` java
public class ReenterLockInt implements Runnable {
    public static ReentrantLock lock1 = new ReentrantLock();
    public static ReentrantLock lock2 = new ReentrantLock();
    int lock;
    /*
    * 控制加锁顺序，方便构成死锁
    * */
    public ReenterLockInt(int lock){
        this.lock = lock;
    }

    @Override
    public void run() {
        try{
            if(lock == 1){
                lock1.lockInterruptibly();  //代表可中断的加锁
                try{
                    Thread.sleep(500);
                }catch (InterruptedException e){}
                lock2.lockInterruptibly();
            }else{
                lock2.lockInterruptibly();
                try{
                    Thread.sleep(500);
                }catch (InterruptedException e){}
                lock1.lockInterruptibly();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if(lock1.isHeldByCurrentThread()){
                lock1.unlock();
            }
            if(lock2.isHeldByCurrentThread()){
                lock2.unlock();
            }
            System.out.println(Thread.currentThread().getId()+":线程退出。");
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReenterLockInt r1 = new ReenterLockInt(1);
        ReenterLockInt r2 = new ReenterLockInt(2);
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);
        t1.start();t2.start();
        Thread.sleep(1000);
    }
}

```

上面这段代码，发生了死锁，程序无法正常结束。通过`jstack`可以看到发现了一个死锁。
![](https://raw.githubusercontent.com/Gengry/blogImage/master/20180222/3.jpg)  

实现是个守护线程，来触发死锁后的中断

``` java
public class DeadLockChecker {

    private final static ThreadMXBean mbean = ManagementFactory.getThreadMXBean();
    final static Runnable deadlockCheck = new Runnable() {
        @Override
        public void run() {
            while (true){
                long[] deadlockedThreadIds = mbean.findDeadlockedThreads();
                if(deadlockedThreadIds != null){
                    ThreadInfo[] threadInfos = mbean.getThreadInfo(deadlockedThreadIds);
                    for (Thread t : Thread.getAllStackTraces().keySet()){
                        for(int i = 0;i<threadInfos.length; i++){
                            if(t.getId() == threadInfos[i].getThreadId()){
                                t.interrupt();
                            }
                        }
                    }
                }
                try {
                    Thread.sleep(5000);
                }catch (InterruptedException e){
                }
            }
        }
    };

    public static void check(){
        Thread t = new Thread(deadlockCheck);
        t.setDaemon(true);  //设置为守护线程
        t.start();
    }
}
```

``` java

 public static void main(String[] args) throws InterruptedException {
        ReenterLockInt r1 = new ReenterLockInt(1);
        ReenterLockInt r2 = new ReenterLockInt(2);
        Thread t1 = new Thread(r1);
        Thread t2 = new Thread(r2);
        t1.start();t2.start();
        Thread.sleep(1000);
		//开启死锁检测
        DeadLockChecker.check();
    }

```

#### 可限时

使用`lock.trylock()`的方式获取锁。

<blockquote class="blockquote-center">今天最好的表现，是明天最低的要求。</blockquote>